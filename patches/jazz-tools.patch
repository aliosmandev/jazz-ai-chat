diff --git a/dist/chunk-7LENDMTN.js b/dist/chunk-7LENDMTN.js
index d6a979992225120704e84b1bfff5f202d8d6e4c4..a211236e7be228762075910bdf1548b52e9e5147 100644
--- a/dist/chunk-7LENDMTN.js
+++ b/dist/chunk-7LENDMTN.js
@@ -28,7 +28,7 @@ var coValuesCache = {
     const computed = compute();
     weakMap.set(raw, computed);
     return computed;
-  }
+  },
 };
 
 // src/implementation/refs.ts
@@ -43,19 +43,24 @@ var Ref = class _Ref {
     }
   }
   get value() {
-    const node = "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
+    const node =
+      "node" in this.controlledAccount
+        ? this.controlledAccount.node
+        : this.controlledAccount._raw.core.node;
     const raw = node.getLoaded(this.id);
     if (raw) {
-      return coValuesCache.get(
-        raw,
-        () => instantiateRefEncoded(this.schema, raw)
+      return coValuesCache.get(raw, () =>
+        instantiateRefEncoded(this.schema, raw)
       );
     } else {
       return null;
     }
   }
   async loadHelper() {
-    const node = "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
+    const node =
+      "node" in this.controlledAccount
+        ? this.controlledAccount.node
+        : this.controlledAccount._raw.core.node;
     const raw = await node.load(this.id);
     if (raw === "unavailable") {
       return "unavailable";
@@ -64,10 +69,11 @@ var Ref = class _Ref {
     }
   }
   syncLoad() {
-    const node = "node" in this.controlledAccount ? this.controlledAccount.node : this.controlledAccount._raw.core.node;
-    const entry = node.coValuesStore.get(
-      this.id
-    );
+    const node =
+      "node" in this.controlledAccount
+        ? this.controlledAccount.node
+        : this.controlledAccount._raw.core.node;
+    const entry = node.coValuesStore.get(this.id);
     if (entry.state.type === "available") {
       return new _Ref(this.id, this.controlledAccount, this.schema).value;
     }
@@ -84,7 +90,8 @@ var Ref = class _Ref {
   accessFrom(fromScopeValue, key) {
     const subScope = subscriptionsScopes.get(fromScopeValue);
     subScope?.onRefAccessedOrSet(fromScopeValue.id, this.id);
-    TRACE_ACCESSES && console.log(subScope?.scopeID, "accessing", fromScopeValue, key, this.id);
+    TRACE_ACCESSES &&
+      console.log(subScope?.scopeID, "accessing", fromScopeValue, key, this.id);
     if (this.value && subScope) {
       subscriptionsScopes.set(this.value, subScope);
     }
@@ -110,7 +117,12 @@ var Ref = class _Ref {
     }
   }
 };
-function makeRefs(getIdForKey, getKeysWithIds, controlledAccount, refSchemaForKey) {
+function makeRefs(
+  getIdForKey,
+  getKeysWithIds,
+  controlledAccount,
+  refSchemaForKey
+) {
   const refs = {};
   return new Proxy(refs, {
     get(_target, key) {
@@ -131,11 +143,7 @@ function makeRefs(getIdForKey, getKeysWithIds, controlledAccount, refSchemaForKe
       }
       const id = getIdForKey(key);
       if (!id) return void 0;
-      return new Ref(
-        id,
-        controlledAccount,
-        refSchemaForKey(key)
-      );
+      return new Ref(id, controlledAccount, refSchemaForKey(key));
     },
     ownKeys() {
       return getKeysWithIds().map((key) => key.toString());
@@ -146,12 +154,12 @@ function makeRefs(getIdForKey, getKeysWithIds, controlledAccount, refSchemaForKe
         return {
           enumerable: true,
           configurable: true,
-          writable: true
+          writable: true,
         };
       } else {
         return Reflect.getOwnPropertyDescriptor(target, key);
       }
-    }
+    },
   });
 }
 
@@ -159,8 +167,8 @@ function makeRefs(getIdForKey, getKeysWithIds, controlledAccount, refSchemaForKe
 var Encoders = {
   Date: {
     encode: (value) => value.toISOString(),
-    decode: (value) => new Date(value)
-  }
+    decode: (value) => new Date(value),
+  },
 };
 var optional = {
   ref: optionalRef,
@@ -171,39 +179,39 @@ var optional = {
     return { [SchemaInit]: { encoded: arg } };
   },
   string: {
-    [SchemaInit]: "json"
+    [SchemaInit]: "json",
   },
   number: {
-    [SchemaInit]: "json"
+    [SchemaInit]: "json",
   },
   boolean: {
-    [SchemaInit]: "json"
+    [SchemaInit]: "json",
   },
   null: {
-    [SchemaInit]: "json"
+    [SchemaInit]: "json",
   },
   Date: {
-    [SchemaInit]: { encoded: Encoders.Date }
+    [SchemaInit]: { encoded: Encoders.Date },
   },
   literal(..._lit) {
     return { [SchemaInit]: "json" };
-  }
+  },
 };
 var co = {
   string: {
-    [SchemaInit]: "json"
+    [SchemaInit]: "json",
   },
   number: {
-    [SchemaInit]: "json"
+    [SchemaInit]: "json",
   },
   boolean: {
-    [SchemaInit]: "json"
+    [SchemaInit]: "json",
   },
   null: {
-    [SchemaInit]: "json"
+    [SchemaInit]: "json",
   },
   Date: {
-    [SchemaInit]: { encoded: Encoders.Date }
+    [SchemaInit]: { encoded: Encoders.Date },
   },
   literal(..._lit) {
     return { [SchemaInit]: "json" };
@@ -217,7 +225,7 @@ var co = {
   ref,
   items: ItemsSym,
   members: MembersSym,
-  optional
+  optional,
 };
 function optionalRef(arg) {
   return ref(arg, { optional: true });
@@ -226,18 +234,23 @@ function ref(arg, options) {
   return {
     [SchemaInit]: {
       ref: arg,
-      optional: options?.optional || false
-    }
+      optional: options?.optional || false,
+    },
     // eslint-disable-next-line @typescript-eslint/no-explicit-any
   };
 }
 function isRefEncoded(schema) {
-  return typeof schema === "object" && "ref" in schema && "optional" in schema && typeof schema.ref === "function";
+  return (
+    typeof schema === "object" &&
+    "ref" in schema &&
+    "optional" in schema &&
+    typeof schema.ref === "function"
+  );
 }
 function instantiateRefEncoded(schema, raw) {
-  return isCoValueClass(schema.ref) ? schema.ref.fromRaw(raw) : schema.ref(
-    raw
-  ).fromRaw(raw);
+  return isCoValueClass(schema.ref)
+    ? schema.ref.fromRaw(raw)
+    : schema.ref(raw).fromRaw(raw);
 }
 
 // src/implementation/subscriptionScope.ts
@@ -263,8 +276,7 @@ var SubscriptionScope = class {
     this.rootEntry = {
       state: "loaded",
       value: root._raw,
-      rawUnsub: () => {
-      }
+      rawUnsub: () => {},
       // placeholder
     };
     this.entries.set(root.id, this.rootEntry);
@@ -275,27 +287,29 @@ var SubscriptionScope = class {
       subscriptionsScopes.set(value, this);
       onUpdate(value, this);
     };
-    this.rootEntry.rawUnsub = root._raw.core.subscribe(
-      (rawUpdate) => {
-        if (!rawUpdate) return;
-        this.rootEntry.value = rawUpdate;
-        this.scheduleUpdate();
-      }
-    );
+    this.rootEntry.rawUnsub = root._raw.core.subscribe((rawUpdate) => {
+      if (!rawUpdate) return;
+      this.rootEntry.value = rawUpdate;
+      this.scheduleUpdate();
+    });
   }
   onRefAccessedOrSet(fromId, accessedOrSetId) {
     if (!accessedOrSetId) {
       return;
     }
-    this.parents[accessedOrSetId] = this.parents[accessedOrSetId] || /* @__PURE__ */ new Set();
+    this.parents[accessedOrSetId] =
+      this.parents[accessedOrSetId] || /* @__PURE__ */ new Set();
     this.parents[accessedOrSetId].add(fromId);
     if (!this.entries.has(accessedOrSetId)) {
       const loadingEntry = {
         state: "loading",
-        immediatelyUnsub: false
+        immediatelyUnsub: false,
       };
       this.entries.set(accessedOrSetId, loadingEntry);
-      const node = this.subscriber._type === "Account" ? this.subscriber._raw.core.node : this.subscriber.node;
+      const node =
+        this.subscriber._type === "Account"
+          ? this.subscriber._raw.core.node
+          : this.subscriber.node;
       void node.loadCoValueCore(accessedOrSetId).then((core) => {
         if (loadingEntry.state === "loading" && loadingEntry.immediatelyUnsub) {
           return;
@@ -303,8 +317,7 @@ var SubscriptionScope = class {
         if (core !== "unavailable") {
           const entry = {
             state: "loaded",
-            rawUnsub: () => {
-            }
+            rawUnsub: () => {},
             // placeholder
           };
           this.entries.set(accessedOrSetId, entry);
@@ -320,7 +333,8 @@ var SubscriptionScope = class {
   }
   invalidate(id, fromChild, seen = /* @__PURE__ */ new Set()) {
     if (seen.has(id)) return;
-    TRACE_INVALIDATIONS && console.log("invalidating", fromChild, "->", id, this.cachedValues[id]);
+    TRACE_INVALIDATIONS &&
+      console.log("invalidating", fromChild, "->", id, this.cachedValues[id]);
     delete this.cachedValues[id];
     seen.add(id);
     for (const parent of this.parents[id] || []) {
@@ -331,10 +345,16 @@ var SubscriptionScope = class {
 
 // src/coValues/deepLoading.ts
 function fulfillsDepth(depth, value) {
-  if (value._type === "CoMap" || value._type === "Group" || value._type === "Account") {
+  if (
+    value._type === "CoMap" ||
+    value._type === "Group" ||
+    value._type === "Account"
+  ) {
     if (Array.isArray(depth) && depth.length === 1) {
       return Object.entries(value).every(([key, item]) => {
-        return value._refs[key] ? item && fulfillsDepth(depth[0], item) : value._schema[ItemsSym].optional;
+        return value._refs[key]
+          ? item && fulfillsDepth(depth[0], item)
+          : value._schema[ItemsSym].optional;
       });
     } else {
       for (const key of Object.keys(depth)) {
@@ -356,8 +376,10 @@ function fulfillsDepth(depth, value) {
       return true;
     } else {
       const itemDepth = depth[0];
-      return value.every(
-        (item, i) => value._refs[i] ? item && fulfillsDepth(itemDepth, item) : value._schema[ItemsSym].optional
+      return value.every((item, i) =>
+        value._refs[i]
+          ? item && fulfillsDepth(itemDepth, item)
+          : value._schema[ItemsSym].optional
       );
     }
   } else if (value._type === "CoStream") {
@@ -365,8 +387,10 @@ function fulfillsDepth(depth, value) {
       return true;
     } else {
       const itemDepth = depth[0];
-      return Object.values(value.perSession).every(
-        (entry) => entry.ref ? entry.value && fulfillsDepth(itemDepth, entry.value) : value._schema[ItemsSym].optional
+      return Object.values(value.perSession).every((entry) =>
+        entry.ref
+          ? entry.value && fulfillsDepth(itemDepth, entry.value)
+          : value._schema[ItemsSym].optional
       );
     }
   } else if (value._type === "BinaryCoStream") {
@@ -378,10 +402,7 @@ function fulfillsDepth(depth, value) {
 }
 
 // src/implementation/createContext.ts
-import {
-  ControlledAgent,
-  LocalNode
-} from "cojson";
+import { ControlledAgent, LocalNode } from "cojson";
 
 // src/coValues/registeredSchemas.ts
 var RegisteredSchemas = {};
@@ -392,15 +413,11 @@ var fixedCredentialsAuth = (credentials) => {
     start: async () => ({
       type: "existing",
       credentials,
-      saveCredentials: async () => {
-      },
-      onSuccess: () => {
-      },
-      onError: () => {
-      },
-      logOut: () => {
-      }
-    })
+      saveCredentials: async () => {},
+      onSuccess: () => {},
+      onError: () => {},
+      logOut: () => {},
+    }),
   };
 };
 var ephemeralCredentialsAuth = () => {
@@ -408,48 +425,50 @@ var ephemeralCredentialsAuth = () => {
     start: async () => ({
       type: "new",
       creationProps: { name: "Ephemeral" },
-      saveCredentials: async () => {
-      },
-      onSuccess: () => {
-      },
-      onError: () => {
-      },
-      logOut: () => {
-      }
-    })
+      saveCredentials: async () => {},
+      onSuccess: () => {},
+      onError: () => {},
+      logOut: () => {},
+    }),
   };
 };
 async function randomSessionProvider(accountID, crypto) {
   return {
     sessionID: crypto.newRandomSessionID(accountID),
-    sessionDone: () => {
-    }
+    sessionDone: () => {},
   };
 }
 async function createJazzContext(options) {
   while (true) {
+    console.log("Creating jazz context");
     if (!("auth" in options)) {
       return createAnonymousJazzContext({
         peersToLoadFrom: options.peersToLoadFrom,
-        crypto: options.crypto
+        crypto: options.crypto,
       });
     }
+    console.log("Auth in options");
     const { auth, sessionProvider, peersToLoadFrom, crypto } = options;
     const AccountSchema = options.AccountSchema ?? RegisteredSchemas["Account"];
     let authResult;
     try {
+      console.log("Starting auth");
       authResult = await auth.start(crypto);
+      console.log("Auth done");
     } catch (e) {
       console.error("error", e);
       throw e;
     }
     if (authResult.type === "existing") {
       try {
+        console.log("Starting session provider");
         const { sessionID, sessionDone } = await sessionProvider(
           authResult.credentials.accountID,
           crypto
         );
+        console.log("Session provider done");
         try {
+          console.log("Starting node with loaded account");
           const node = await LocalNode.withLoadedAccount({
             accountID: authResult.credentials.accountID,
             accountSecret: authResult.credentials.secret,
@@ -458,19 +477,24 @@ async function createJazzContext(options) {
             crypto,
             migration: async (rawAccount, _node, creationProps) => {
               const account2 = new AccountSchema({
-                fromRaw: rawAccount
+                fromRaw: rawAccount,
               });
               await account2.applyMigration(creationProps);
-            }
+            },
           });
+          console.log("Node with loaded account done");
           const account = AccountSchema.fromNode(node);
+          console.log("Account created");
           if (authResult.saveCredentials) {
+            console.log("Saving credentials");
             await authResult.saveCredentials({
               accountID: node.account.id,
-              secret: node.account.agentSecret
+              secret: node.account.agentSecret,
             });
           }
+          console.log("On success");
           authResult.onSuccess();
+          console.log("On success done");
           return {
             account,
             done: () => {
@@ -481,7 +505,7 @@ async function createJazzContext(options) {
               node.gracefulShutdown();
               sessionDone();
               authResult.logOut();
-            }
+            },
           };
         } catch (e) {
           authResult.onError(new Error("Error loading account", { cause: e }));
@@ -494,6 +518,8 @@ async function createJazzContext(options) {
       }
     } else if (authResult.type === "new") {
       try {
+        // TODO: figure out a way to not "waste" the first SessionID
+        console.log("Creating node with newly created account");
         const { node } = await LocalNode.withNewlyCreatedAccount({
           creationProps: authResult.creationProps,
           peersToLoadFrom,
@@ -501,16 +527,19 @@ async function createJazzContext(options) {
           initialAgentSecret: authResult.initialSecret,
           migration: async (rawAccount, _node, creationProps) => {
             const account2 = new AccountSchema({
-              fromRaw: rawAccount
+              fromRaw: rawAccount,
             });
             await account2.applyMigration(creationProps);
-          }
+          },
         });
+        console.log("Node with newly created account done");
         const account = AccountSchema.fromNode(node);
+        console.log("Account created");
         await authResult.saveCredentials({
           accountID: node.account.id,
-          secret: node.account.agentSecret
+          secret: node.account.agentSecret,
         });
+        console.log("Credentials saved");
         authResult.onSuccess();
         return {
           account,
@@ -520,7 +549,7 @@ async function createJazzContext(options) {
           logOut: () => {
             node.gracefulShutdown();
             authResult.logOut();
-          }
+          },
         };
       } catch (e) {
         authResult.onError(new Error("Error creating account", { cause: e }));
@@ -528,10 +557,7 @@ async function createJazzContext(options) {
     }
   }
 }
-async function createAnonymousJazzContext({
-  peersToLoadFrom,
-  crypto
-}) {
+async function createAnonymousJazzContext({ peersToLoadFrom, crypto }) {
   const agentSecret = crypto.newRandomAgentSecret();
   const rawAgent = new ControlledAgent(agentSecret, crypto);
   const node = new LocalNode(
@@ -544,10 +570,8 @@ async function createAnonymousJazzContext({
   }
   return {
     agent: new AnonymousJazzAgent(node),
-    done: () => {
-    },
-    logOut: () => {
-    }
+    done: () => {},
+    logOut: () => {},
   };
 }
 
@@ -561,7 +585,7 @@ globalThis.devtoolsFormatters = [
         return [
           "div",
           {},
-          ["span", {}, object.constructor.name + "(" + object.length + ") "]
+          ["span", {}, object.constructor.name + "(" + object.length + ") "],
         ];
       } else if (object._type === "Account") {
         return [
@@ -570,17 +594,21 @@ globalThis.devtoolsFormatters = [
           [
             "span",
             {},
-            object.constructor.name + "(" + object._refs.profile.value?.name + (object.isMe ? " ME" : "") + ")"
-          ]
+            object.constructor.name +
+              "(" +
+              object._refs.profile.value?.name +
+              (object.isMe ? " ME" : "") +
+              ")",
+          ],
         ];
       } else {
         return null;
       }
     },
-    hasBody: function() {
+    hasBody: function () {
       return true;
     },
-    body: function(object) {
+    body: function (object) {
       if (object._type === "CoMap" || object._type === "Account") {
         return [
           "div",
@@ -591,16 +619,20 @@ globalThis.devtoolsFormatters = [
             { style: "white-space: nowrap;" },
             ["span", { style: "font-weight: bold; opacity: 0.6" }, k, ": "],
             ["object", { object: v }],
-            ...typeof object._schema[k] === "function" ? v === null ? [
-              [
-                "span",
-                { style: "opacity: 0.5" },
-                ` (pending ${object._schema[k].name} `,
-                ["object", { object: object._refs[k] }],
-                ")"
-              ]
-            ] : [] : []
-          ])
+            ...(typeof object._schema[k] === "function"
+              ? v === null
+                ? [
+                    [
+                      "span",
+                      { style: "opacity: 0.5" },
+                      ` (pending ${object._schema[k].name} `,
+                      ["object", { object: object._refs[k] }],
+                      ")",
+                    ],
+                  ]
+                : []
+              : []),
+          ]),
         ];
       } else if (object._type === "CoList") {
         return [
@@ -612,20 +644,24 @@ globalThis.devtoolsFormatters = [
             { style: "white-space: nowrap;" },
             ["span", { style: "font-weight: bold; opacity: 0.6" }, i, ": "],
             ["object", { object: v }],
-            ...typeof object._schema[ItemsSym] === "function" ? v === null ? [
-              [
-                "span",
-                { style: "opacity: 0.5" },
-                ` (pending ${object._schema[ItemsSym].name} `,
-                ["object", { object: object._refs[i] }],
-                ")"
-              ]
-            ] : [] : []
-          ])
+            ...(typeof object._schema[ItemsSym] === "function"
+              ? v === null
+                ? [
+                    [
+                      "span",
+                      { style: "opacity: 0.5" },
+                      ` (pending ${object._schema[ItemsSym].name} `,
+                      ["object", { object: object._refs[i] }],
+                      ")",
+                    ],
+                  ]
+                : []
+              : []),
+          ]),
         ];
       }
-    }
-  }
+    },
+  },
 ];
 
 // src/coValues/interfaces.ts
@@ -634,7 +670,10 @@ function isCoValueClass(value) {
 }
 var CoValueBase = class {
   get _owner() {
-    const owner = this._raw.group instanceof RawAccount2 ? RegisteredSchemas["Account"].fromRaw(this._raw.group) : RegisteredSchemas["Group"].fromRaw(this._raw.group);
+    const owner =
+      this._raw.group instanceof RawAccount2
+        ? RegisteredSchemas["Account"].fromRaw(this._raw.group)
+        : RegisteredSchemas["Group"].fromRaw(this._raw.group);
     const subScope = subscriptionsScopes.get(this);
     if (subScope) {
       subScope.onRefAccessedOrSet(this.id, owner.id);
@@ -646,9 +685,8 @@ var CoValueBase = class {
   get _loadedAs() {
     const rawAccount = this._raw.core.node.account;
     if (rawAccount instanceof RawAccount2) {
-      return coValuesCache.get(
-        rawAccount,
-        () => RegisteredSchemas["Account"].fromRaw(rawAccount)
+      return coValuesCache.get(rawAccount, () =>
+        RegisteredSchemas["Account"].fromRaw(rawAccount)
       );
     }
     return new AnonymousJazzAgent(this._raw.core.node);
@@ -657,7 +695,7 @@ var CoValueBase = class {
   constructor(..._args) {
     Object.defineProperty(this, "_instanceID", {
       value: `instance-${Math.random().toString(36).slice(2)}`,
-      enumerable: false
+      enumerable: false,
     });
   }
   /** @category Internals */
@@ -669,7 +707,7 @@ var CoValueBase = class {
     return {
       id: this.id,
       type: this._type,
-      error: "unknown CoValue class"
+      error: "unknown CoValue class",
     };
   }
   [inspect]() {
@@ -710,7 +748,15 @@ function ensureCoValueLoaded(existing, depth) {
     depth
   );
 }
-function subscribeToCoValue(cls, id, as, depth, listener, onUnavailable, syncResolution) {
+function subscribeToCoValue(
+  cls,
+  id,
+  as,
+  depth,
+  listener,
+  onUnavailable,
+  syncResolution
+) {
   const ref2 = new Ref(id, as, { ref: cls, optional: false });
   let unsubscribed = false;
   let unsubscribe;
@@ -725,10 +771,7 @@ function subscribeToCoValue(cls, id, as, depth, listener, onUnavailable, syncRes
       cls,
       (update, subscription2) => {
         if (fulfillsDepth(depth, update)) {
-          listener(
-            update,
-            subscription2.unsubscribeAll
-          );
+          listener(update, subscription2.unsubscribeAll);
         }
       }
     );
@@ -738,9 +781,12 @@ function subscribeToCoValue(cls, id, as, depth, listener, onUnavailable, syncRes
   if (sync) {
     subscribe(sync);
   } else {
-    ref2.load().then((value) => subscribe(value)).catch((e) => {
-      console.error("Failed to load / subscribe to CoValue", e);
-    });
+    ref2
+      .load()
+      .then((value) => subscribe(value))
+      .catch((e) => {
+        console.error("Failed to load / subscribe to CoValue", e);
+      });
   }
   return function unsubscribeAtAnyPoint() {
     unsubscribed = true;
@@ -774,7 +820,7 @@ function createCoValueObservable(options) {
   }
   const observable = {
     getCurrentValue: () => currentValue,
-    subscribe
+    subscribe,
   };
   return observable;
 }
@@ -788,16 +834,17 @@ function subscribeToExistingCoValue(existing, depth, listener) {
   );
 }
 function parseCoValueCreateOptions(options) {
-  return "_type" in options && (options._type === "Account" || options._type === "Group") ? { owner: options, uniqueness: void 0 } : {
-    owner: options.owner,
-    uniqueness: options.unique ? { uniqueness: options.unique } : void 0
-  };
+  return "_type" in options &&
+    (options._type === "Account" || options._type === "Group")
+    ? { owner: options, uniqueness: void 0 }
+    : {
+        owner: options.owner,
+        uniqueness: options.unique ? { uniqueness: options.unique } : void 0,
+      };
 }
 
 // src/coValues/inbox.ts
-import {
-  RawAccount as RawAccount3
-} from "cojson";
+import { RawAccount as RawAccount3 } from "cojson";
 function createInboxRoot(account) {
   if (!account.isMe) {
     throw new Error("Account is not controlled");
@@ -814,7 +861,7 @@ function createInboxRoot(account) {
   inboxRoot.set("failed", failedFeed.id);
   return {
     id: inboxRoot.id,
-    inviteLink
+    inviteLink,
   };
 }
 function createInboxMessage(payload, inboxOwner) {
@@ -827,7 +874,7 @@ function createInboxMessage(payload, inboxOwner) {
     payload: payload.id,
     result: void 0,
     processed: false,
-    error: void 0
+    error: void 0,
   });
   return message;
 }
@@ -871,55 +918,59 @@ var Inbox = class _Inbox {
           if (!processed.has(txKey) && !this.processing.has(txKey)) {
             this.processing.add(txKey);
             const id = item.value;
-            node.load(id).then((message) => {
-              if (message === "unavailable") {
-                return Promise.reject(
-                  new Error("Unable to load inbox message " + id)
-                );
-              }
-              return loadCoValue(
-                Schema,
-                message.get("payload"),
-                account,
-                []
-              );
-            }).then((value) => {
-              if (!value) {
-                return Promise.reject(
-                  new Error("Unable to load inbox message " + id)
-                );
-              }
-              return callback(value, accountID);
-            }).then((result) => {
-              const inboxMessage = node.expectCoValueLoaded(item.value).getCurrentContent();
-              if (result) {
-                inboxMessage.set("result", result.id);
-              }
-              inboxMessage.set("processed", true);
-              this.processed.push(txKey);
-              this.processing.delete(txKey);
-            }).catch((error) => {
-              console.error("Error processing inbox message", error);
-              this.processing.delete(txKey);
-              const errors = failed.get(txKey) ?? [];
-              const stringifiedError = String(error);
-              errors.push(stringifiedError);
-              const inboxMessage = node.expectCoValueLoaded(item.value).getCurrentContent();
-              inboxMessage.set("error", stringifiedError);
-              if (errors.length > retries) {
+            node
+              .load(id)
+              .then((message) => {
+                if (message === "unavailable") {
+                  return Promise.reject(
+                    new Error("Unable to load inbox message " + id)
+                  );
+                }
+                return loadCoValue(Schema, message.get("payload"), account, []);
+              })
+              .then((value) => {
+                if (!value) {
+                  return Promise.reject(
+                    new Error("Unable to load inbox message " + id)
+                  );
+                }
+                return callback(value, accountID);
+              })
+              .then((result) => {
+                const inboxMessage = node
+                  .expectCoValueLoaded(item.value)
+                  .getCurrentContent();
+                if (result) {
+                  inboxMessage.set("result", result.id);
+                }
                 inboxMessage.set("processed", true);
                 this.processed.push(txKey);
-                this.failed.push({ errors, value: item.value });
-              } else {
-                failed.set(txKey, errors);
-                if (!failTimer) {
-                  failTimer = setTimeout(
-                    () => handleNewMessages(stream),
-                    100
-                  );
+                this.processing.delete(txKey);
+              })
+              .catch((error) => {
+                console.error("Error processing inbox message", error);
+                this.processing.delete(txKey);
+                const errors = failed.get(txKey) ?? [];
+                const stringifiedError = String(error);
+                errors.push(stringifiedError);
+                const inboxMessage = node
+                  .expectCoValueLoaded(item.value)
+                  .getCurrentContent();
+                inboxMessage.set("error", stringifiedError);
+                if (errors.length > retries) {
+                  inboxMessage.set("processed", true);
+                  this.processed.push(txKey);
+                  this.failed.push({ errors, value: item.value });
+                } else {
+                  failed.set(txKey, errors);
+                  if (!failTimer) {
+                    failTimer = setTimeout(
+                      () => handleNewMessages(stream),
+                      100
+                    );
+                  }
                 }
-              }
-            });
+              });
           }
         }
       }
@@ -942,9 +993,13 @@ var Inbox = class _Inbox {
     const [messages, processed, failed] = await Promise.all([
       node.load(root.get("messages")),
       node.load(root.get("processed")),
-      node.load(root.get("failed"))
+      node.load(root.get("failed")),
     ]);
-    if (messages === "unavailable" || processed === "unavailable" || failed === "unavailable") {
+    if (
+      messages === "unavailable" ||
+      processed === "unavailable" ||
+      failed === "unavailable"
+    ) {
       throw new Error("Inbox not found");
     }
     return new _Inbox(account, root, messages, processed, failed);
@@ -969,9 +1024,7 @@ var InboxSender = class _InboxSender {
           if (error) {
             reject(new Error(error));
           } else {
-            resolve(
-              message2.get("result")
-            );
+            resolve(message2.get("result"));
           }
         }
       });
@@ -979,9 +1032,7 @@ var InboxSender = class _InboxSender {
   }
   static async load(inboxOwnerID, currentAccount) {
     const node = currentAccount._raw.core.node;
-    const inboxOwnerRaw = await node.load(
-      inboxOwnerID
-    );
+    const inboxOwnerRaw = await node.load(inboxOwnerID);
     if (inboxOwnerRaw === "unavailable") {
       throw new Error("Failed to load the inbox owner");
     }
@@ -1023,9 +1074,7 @@ function getAccountIDfromSessionID(sessionID) {
 }
 
 // src/coValues/coMap.ts
-import {
-  cojsonInternals
-} from "cojson";
+import { cojsonInternals } from "cojson";
 var _CoMap = class _CoMap extends CoValueBase {
   /** @internal */
   get _schema() {
@@ -1065,18 +1114,29 @@ var _CoMap = class _CoMap extends CoValueBase {
   /** @internal */
   getEditFromRaw(target, rawEdit, descriptor, key) {
     return {
-      value: descriptor === "json" ? rawEdit.value : "encoded" in descriptor ? rawEdit.value === null || rawEdit.value === void 0 ? rawEdit.value : descriptor.encoded.decode(rawEdit.value) : new Ref(
-        rawEdit.value,
-        target._loadedAs,
-        descriptor
-      ).accessFrom(target, "_edits." + key + ".value"),
-      ref: descriptor !== "json" && isRefEncoded(descriptor) ? new Ref(rawEdit.value, target._loadedAs, descriptor) : void 0,
-      by: rawEdit.by && new Ref(rawEdit.by, target._loadedAs, {
-        ref: RegisteredSchemas["Account"],
-        optional: false
-      }).accessFrom(target, "_edits." + key + ".by"),
+      value:
+        descriptor === "json"
+          ? rawEdit.value
+          : "encoded" in descriptor
+          ? rawEdit.value === null || rawEdit.value === void 0
+            ? rawEdit.value
+            : descriptor.encoded.decode(rawEdit.value)
+          : new Ref(rawEdit.value, target._loadedAs, descriptor).accessFrom(
+              target,
+              "_edits." + key + ".value"
+            ),
+      ref:
+        descriptor !== "json" && isRefEncoded(descriptor)
+          ? new Ref(rawEdit.value, target._loadedAs, descriptor)
+          : void 0,
+      by:
+        rawEdit.by &&
+        new Ref(rawEdit.by, target._loadedAs, {
+          ref: RegisteredSchemas["Account"],
+          optional: false,
+        }).accessFrom(target, "_edits." + key + ".by"),
       madeAt: rawEdit.at,
-      key
+      key,
     };
   }
   /** @category Collaboration */
@@ -1092,10 +1152,10 @@ var _CoMap = class _CoMap extends CoValueBase {
           return {
             ...map.getEditFromRaw(map, rawEdit, descriptor, key),
             get all() {
-              return [...map._raw.editsAt(key)].map(
-                (rawEdit2) => map.getEditFromRaw(map, rawEdit2, descriptor, key)
+              return [...map._raw.editsAt(key)].map((rawEdit2) =>
+                map.getEditFromRaw(map, rawEdit2, descriptor, key)
               );
-            }
+            },
           };
         },
         ownKeys(_target) {
@@ -1106,9 +1166,9 @@ var _CoMap = class _CoMap extends CoValueBase {
             value: Reflect.get(target, key),
             writable: false,
             enumerable: true,
-            configurable: true
+            configurable: true,
           };
-        }
+        },
       }
     );
   }
@@ -1120,9 +1180,9 @@ var _CoMap = class _CoMap extends CoValueBase {
         Object.defineProperties(this, {
           id: {
             value: options.fromRaw.id,
-            enumerable: false
+            enumerable: false,
           },
-          _raw: { value: options.fromRaw, enumerable: false }
+          _raw: { value: options.fromRaw, enumerable: false },
         });
       } else {
         throw new Error("Invalid CoMap constructor arguments");
@@ -1155,9 +1215,9 @@ var _CoMap = class _CoMap extends CoValueBase {
     Object.defineProperties(instance, {
       id: {
         value: raw.id,
-        enumerable: false
+        enumerable: false,
       },
-      _raw: { value: raw, enumerable: false }
+      _raw: { value: raw, enumerable: false },
     });
     return instance;
   }
@@ -1177,8 +1237,8 @@ var _CoMap = class _CoMap extends CoValueBase {
           return [key, { _circular: this[tKey]?.id }];
         }
         const jsonedRef = this[tKey]?.toJSON(tKey, [
-          ...seenAbove || [],
-          this.id
+          ...(seenAbove || []),
+          this.id,
         ]);
         return [key, jsonedRef];
       } else {
@@ -1188,7 +1248,7 @@ var _CoMap = class _CoMap extends CoValueBase {
     return {
       id: this.id,
       _type: this._type,
-      ...Object.fromEntries(jsonedFields)
+      ...Object.fromEntries(jsonedFields),
     };
   }
   [inspect]() {
@@ -1244,7 +1304,7 @@ var _CoMap = class _CoMap extends CoValueBase {
    */
   static Record(value) {
     var _a2, _b2;
-    class RecordLikeCoMap extends (_b2 = _CoMap, _a2 = ItemsSym, _b2) {
+    class RecordLikeCoMap extends ((_b2 = _CoMap), (_a2 = ItemsSym), _b2) {
       constructor() {
         super(...arguments);
         this[_a2] = value;
@@ -1312,12 +1372,13 @@ var _CoMap = class _CoMap extends CoValueBase {
       type: "comap",
       ruleset: {
         type: "ownedByGroup",
-        group: ownerID
+        group: ownerID,
       },
       meta: null,
-      uniqueness: unique
+      uniqueness: unique,
     };
-    const crypto = as._type === "Anonymous" ? as.node.crypto : as._raw.core.crypto;
+    const crypto =
+      as._type === "Anonymous" ? as.node.crypto : as._raw.core.crypto;
     return cojsonInternals.idforHeader(header, crypto);
   }
   /**
@@ -1396,11 +1457,12 @@ var CoMapProxyHandler = {
         } else if ("encoded" in descriptor) {
           return raw === void 0 ? void 0 : descriptor.encoded.decode(raw);
         } else if (isRefEncoded(descriptor)) {
-          return raw === void 0 ? void 0 : new Ref(
-            raw,
-            target._loadedAs,
-            descriptor
-          ).accessFrom(receiver, key);
+          return raw === void 0
+            ? void 0
+            : new Ref(raw, target._loadedAs, descriptor).accessFrom(
+                receiver,
+                key
+              );
         }
       } else {
         return void 0;
@@ -1408,7 +1470,12 @@ var CoMapProxyHandler = {
     }
   },
   set(target, key, value, receiver) {
-    if ((typeof key === "string" || ItemsSym) && typeof value === "object" && value !== null && SchemaInit in value) {
+    if (
+      (typeof key === "string" || ItemsSym) &&
+      typeof value === "object" &&
+      value !== null &&
+      SchemaInit in value
+    ) {
       target.constructor._schema ||= {};
       target.constructor._schema[key] = value[SchemaInit];
       return true;
@@ -1428,7 +1495,9 @@ var CoMapProxyHandler = {
           }
         } else {
           target._raw.set(key, value.id);
-          subscriptionsScopes.get(target)?.onRefAccessedOrSet(target.id, value.id);
+          subscriptionsScopes
+            .get(target)
+            ?.onRefAccessedOrSet(target.id, value.id);
         }
       }
       return true;
@@ -1437,7 +1506,11 @@ var CoMapProxyHandler = {
     }
   },
   defineProperty(target, key, attributes) {
-    if ("value" in attributes && typeof attributes.value === "object" && SchemaInit in attributes.value) {
+    if (
+      "value" in attributes &&
+      typeof attributes.value === "object" &&
+      SchemaInit in attributes.value
+    ) {
       target.constructor._schema ||= {};
       target.constructor._schema[key] = attributes.value[SchemaInit];
       return true;
@@ -1463,7 +1536,7 @@ var CoMapProxyHandler = {
         return {
           enumerable: true,
           configurable: true,
-          writable: true
+          writable: true,
         };
       }
     }
@@ -1484,7 +1557,7 @@ var CoMapProxyHandler = {
     } else {
       return Reflect.deleteProperty(target, key);
     }
-  }
+  },
 };
 RegisteredSchemas["CoMap"] = CoMap;
 
@@ -1502,7 +1575,7 @@ var Profile = class extends CoMap {
 import {
   LocalNode as LocalNode2,
   RawAccount as RawAccount4,
-  cojsonInternals as cojsonInternals2
+  cojsonInternals as cojsonInternals2,
 } from "cojson";
 var _Account = class _Account extends CoValueBase {
   get _schema() {
@@ -1523,18 +1596,22 @@ var _Account = class _Account extends CoValueBase {
     const profileID = this._raw.get("profile");
     const rootID = this._raw.get("root");
     return {
-      profile: profileID && new Ref(
-        profileID,
-        this._loadedAs,
-        this._schema.profile
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-      ),
-      root: rootID && new Ref(
-        rootID,
-        this._loadedAs,
-        this._schema.root
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-      )
+      profile:
+        profileID &&
+        new Ref(
+          profileID,
+          this._loadedAs,
+          this._schema.profile
+          // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        ),
+      root:
+        rootID &&
+        new Ref(
+          rootID,
+          this._loadedAs,
+          this._schema.root
+          // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        ),
     };
   }
   constructor(options) {
@@ -1546,10 +1623,10 @@ var _Account = class _Account extends CoValueBase {
     Object.defineProperties(this, {
       id: {
         value: options.fromRaw.id,
-        enumerable: false
+        enumerable: false,
       },
       _raw: { value: options.fromRaw, enumerable: false },
-      _type: { value: "Account", enumerable: false }
+      _type: { value: "Account", enumerable: false },
     });
     if (this.isMe) {
       this.sessionID = options.fromRaw.core.node.currentSessionID;
@@ -1565,10 +1642,7 @@ var _Account = class _Account extends CoValueBase {
     if (!this.isMe) {
       throw new Error("Only a controlled account can accept invites");
     }
-    await this._raw.acceptInvite(
-      valueID,
-      inviteSecret
-    );
+    await this._raw.acceptInvite(valueID, inviteSecret);
     return loadCoValue(coValueClass, valueID, this, []);
   }
   /** @private */
@@ -1577,10 +1651,10 @@ var _Account = class _Account extends CoValueBase {
       ...options,
       migration: async (rawAccount, _node, creationProps) => {
         const account = new this({
-          fromRaw: rawAccount
+          fromRaw: rawAccount,
         });
         await account.applyMigration?.(creationProps);
-      }
+      },
     });
     return this.fromNode(node);
   }
@@ -1594,19 +1668,19 @@ var _Account = class _Account extends CoValueBase {
     return this.create({
       creationProps: options.creationProps,
       crypto: as._raw.core.node.crypto,
-      peersToLoadFrom: [connectedPeers[0]]
+      peersToLoadFrom: [connectedPeers[0]],
     });
   }
   static fromNode(node) {
     return new this({
-      fromRaw: node.account
+      fromRaw: node.account,
     });
   }
   // eslint-disable-next-line @typescript-eslint/no-explicit-any
   toJSON() {
     return {
       id: this.id,
-      _type: this._type
+      _type: this._type,
     };
   }
   [inspect]() {
@@ -1622,7 +1696,9 @@ var _Account = class _Account extends CoValueBase {
       );
     }
     const node = this._raw.core.node;
-    const profile = node.expectCoValueLoaded(this._raw.get("profile")).getCurrentContent();
+    const profile = node
+      .expectCoValueLoaded(this._raw.get("profile"))
+      .getCurrentContent();
     if (!profile.get("inbox")) {
       const inboxRoot = createInboxRoot(this);
       profile.set("inbox", inboxRoot.id);
@@ -1672,22 +1748,22 @@ var _Account = class _Account extends CoValueBase {
 _Account._schema = {
   profile: {
     ref: () => Profile,
-    optional: false
+    optional: false,
   },
   root: {
     ref: () => RegisteredSchemas["CoMap"],
-    optional: true
-  }
+    optional: true,
+  },
 };
 var Account = _Account;
 var AccountAndGroupProxyHandler = {
   get(target, key, receiver) {
     if (key === "profile") {
       const ref2 = target._refs.profile;
-      return ref2 ? ref2.accessFrom(receiver, "profile") : (
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-        void 0
-      );
+      return ref2
+        ? ref2.accessFrom(receiver, "profile")
+        : // eslint-disable-next-line @typescript-eslint/no-explicit-any
+          void 0;
     } else if (key === "root") {
       const ref2 = target._refs.root;
       return ref2 ? ref2.accessFrom(receiver, "root") : void 0;
@@ -1696,39 +1772,47 @@ var AccountAndGroupProxyHandler = {
     }
   },
   set(target, key, value, receiver) {
-    if ((key === "profile" || key === "root" || key === MembersSym) && typeof value === "object" && SchemaInit in value) {
+    if (
+      (key === "profile" || key === "root" || key === MembersSym) &&
+      typeof value === "object" &&
+      SchemaInit in value
+    ) {
       target.constructor._schema ||= {};
       target.constructor._schema[key] = value[SchemaInit];
       return true;
     } else if (key === "profile") {
       if (value) {
-        target._raw.set(
-          "profile",
-          value.id,
-          "trusting"
-        );
+        target._raw.set("profile", value.id, "trusting");
       }
-      subscriptionsScopes.get(receiver)?.onRefAccessedOrSet(target.id, value.id);
+      subscriptionsScopes
+        .get(receiver)
+        ?.onRefAccessedOrSet(target.id, value.id);
       return true;
     } else if (key === "root") {
       if (value) {
         target._raw.set("root", value.id);
       }
-      subscriptionsScopes.get(receiver)?.onRefAccessedOrSet(target.id, value.id);
+      subscriptionsScopes
+        .get(receiver)
+        ?.onRefAccessedOrSet(target.id, value.id);
       return true;
     } else {
       return Reflect.set(target, key, value, receiver);
     }
   },
   defineProperty(target, key, descriptor) {
-    if ((key === "profile" || key === "root" || key === MembersSym) && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
+    if (
+      (key === "profile" || key === "root" || key === MembersSym) &&
+      typeof descriptor.value === "object" &&
+      SchemaInit in descriptor.value
+    ) {
       target.constructor._schema ||= {};
       target.constructor._schema[key] = descriptor.value[SchemaInit];
       return true;
     } else {
       return Reflect.defineProperty(target, key, descriptor);
     }
-  }
+  },
 };
 function isControlledAccount(account) {
   return account.isMe;
@@ -1744,18 +1828,22 @@ var _Group = class _Group extends CoValueBase {
     const profileID = this._raw.get("profile");
     const rootID = this._raw.get("root");
     return {
-      profile: profileID && new Ref(
-        profileID,
-        this._loadedAs,
-        this._schema.profile
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-      ),
-      root: rootID && new Ref(
-        rootID,
-        this._loadedAs,
-        this._schema.root
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-      )
+      profile:
+        profileID &&
+        new Ref(
+          profileID,
+          this._loadedAs,
+          this._schema.profile
+          // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        ),
+      root:
+        rootID &&
+        new Ref(
+          rootID,
+          this._loadedAs,
+          this._schema.root
+          // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        ),
     };
   }
   /** @deprecated Don't use constructor directly, use .create */
@@ -1777,9 +1865,9 @@ var _Group = class _Group extends CoValueBase {
     Object.defineProperties(this, {
       id: {
         value: raw.id,
-        enumerable: false
+        enumerable: false,
       },
-      _raw: { value: raw, enumerable: false }
+      _raw: { value: raw, enumerable: false },
     });
     return new Proxy(this, AccountAndGroupProxyHandler);
   }
@@ -1798,26 +1886,27 @@ var _Group = class _Group extends CoValueBase {
     return this;
   }
   get members() {
-    return this._raw.keys().filter((key) => {
-      return key === "everyone" || key.startsWith("co_");
-    }).map((id) => {
-      const role = this._raw.get(id);
-      const accountID = id === "everyone" ? void 0 : id;
-      const ref2 = accountID && new Ref(
-        accountID,
-        this._loadedAs,
-        this._schema[MembersSym]
-      );
-      const accessRef = () => ref2?.accessFrom(this, "members." + id);
-      return {
-        id,
-        role,
-        ref: ref2,
-        get account() {
-          return accessRef();
-        }
-      };
-    });
+    return this._raw
+      .keys()
+      .filter((key) => {
+        return key === "everyone" || key.startsWith("co_");
+      })
+      .map((id) => {
+        const role = this._raw.get(id);
+        const accountID = id === "everyone" ? void 0 : id;
+        const ref2 =
+          accountID &&
+          new Ref(accountID, this._loadedAs, this._schema[MembersSym]);
+        const accessRef = () => ref2?.accessFrom(this, "members." + id);
+        return {
+          id,
+          role,
+          ref: ref2,
+          get account() {
+            return accessRef();
+          },
+        };
+      });
   }
   extend(parent) {
     this._raw.extend(parent._raw);
@@ -1854,18 +1943,21 @@ _Group._schema = {
   root: "json",
   [MembersSym]: {
     ref: () => RegisteredSchemas["Account"],
-    optional: false
-  }
+    optional: false,
+  },
   // eslint-disable-next-line @typescript-eslint/no-explicit-any
 };
 Object.defineProperty(_Group.prototype, "_schema", {
-  get: () => _Group._schema
+  get: () => _Group._schema,
 });
 var Group = _Group;
 RegisteredSchemas["Group"] = Group;
 
 // src/coValues/coFeed.ts
-import { MAX_RECOMMENDED_TX_SIZE, cojsonInternals as cojsonInternals3 } from "cojson";
+import {
+  MAX_RECOMMENDED_TX_SIZE,
+  cojsonInternals as cojsonInternals3,
+} from "cojson";
 var _CoFeed = class _CoFeed extends CoValueBase {
   /**
    * Declare a `CoFeed` by subclassing `CoFeed.Of(...)` and passing the item schema using a `co` primitive or a `co.ref`.
@@ -1880,7 +1972,7 @@ var _CoFeed = class _CoFeed extends CoValueBase {
    */
   static Of(item) {
     var _a2, _b2;
-    return class CoFeedOf extends (_b2 = _CoFeed, _a2 = co.items, _b2) {
+    return class CoFeedOf extends ((_b2 = _CoFeed), (_a2 = co.items), _b2) {
       constructor() {
         super(...arguments);
         this[_a2] = item;
@@ -1922,9 +2014,9 @@ var _CoFeed = class _CoFeed extends CoValueBase {
       Object.defineProperties(this, {
         id: {
           value: options.fromRaw.id,
-          enumerable: false
+          enumerable: false,
         },
-        _raw: { value: options.fromRaw, enumerable: false }
+        _raw: { value: options.fromRaw, enumerable: false },
       });
     }
     return new Proxy(this, CoStreamProxyHandler);
@@ -1940,9 +2032,9 @@ var _CoFeed = class _CoFeed extends CoValueBase {
     Object.defineProperties(instance, {
       id: {
         value: raw.id,
-        enumerable: false
+        enumerable: false,
       },
-      _raw: { value: raw, enumerable: false }
+      _raw: { value: raw, enumerable: false },
     });
     if (init) {
       instance.push(...init);
@@ -1990,22 +2082,27 @@ var _CoFeed = class _CoFeed extends CoValueBase {
    */
   toJSON() {
     const itemDescriptor = this._schema[ItemsSym];
-    const mapper = itemDescriptor === "json" ? (v) => v : "encoded" in itemDescriptor ? itemDescriptor.encoded.encode : (v) => v && v.id;
+    const mapper =
+      itemDescriptor === "json"
+        ? (v) => v
+        : "encoded" in itemDescriptor
+        ? itemDescriptor.encoded.encode
+        : (v) => v && v.id;
     return {
       id: this.id,
       _type: this._type,
       ...Object.fromEntries(
         Object.entries(this).map(([account, entry]) => [
           account,
-          mapper(entry.value)
+          mapper(entry.value),
         ])
       ),
       in: Object.fromEntries(
         Object.entries(this.perSession).map(([session, entry]) => [
           session,
-          mapper(entry.value)
+          mapper(entry.value),
         ])
-      )
+      ),
     };
   }
   /** @internal */
@@ -2061,7 +2158,13 @@ var _CoFeed = class _CoFeed extends CoValueBase {
 };
 _CoFeed.prototype._type = "CoStream";
 var CoFeed = _CoFeed;
-function entryFromRawEntry(accessFrom, rawEntry, loadedAs, accountID, itemField) {
+function entryFromRawEntry(
+  accessFrom,
+  rawEntry,
+  loadedAs,
+  accountID,
+  itemField
+) {
   return {
     get value() {
       if (itemField === "json") {
@@ -2080,26 +2183,25 @@ function entryFromRawEntry(accessFrom, rawEntry, loadedAs, accountID, itemField)
     get ref() {
       if (itemField !== "json" && isRefEncoded(itemField)) {
         const rawId = rawEntry.value;
-        return new Ref(
-          rawId,
-          loadedAs,
-          itemField
-        );
+        return new Ref(rawId, loadedAs, itemField);
       } else {
         return void 0;
       }
     },
     get by() {
-      return accountID && new Ref(accountID, loadedAs, {
-        ref: RegisteredSchemas["Account"],
-        optional: false
-      })?.accessFrom(
-        accessFrom,
-        rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + ".by"
+      return (
+        accountID &&
+        new Ref(accountID, loadedAs, {
+          ref: RegisteredSchemas["Account"],
+          optional: false,
+        })?.accessFrom(
+          accessFrom,
+          rawEntry.by + rawEntry.tx.sessionID + rawEntry.tx.txIndex + ".by"
+        )
       );
     },
     madeAt: rawEntry.at,
-    tx: rawEntry.tx
+    tx: rawEntry.tx,
   };
 }
 var CoStreamProxyHandler = {
@@ -2117,7 +2219,7 @@ var CoStreamProxyHandler = {
       Object.defineProperty(entry, "all", {
         get: () => {
           const allRawEntries = target._raw.itemsBy(key);
-          return function* () {
+          return (function* () {
             while (true) {
               const rawEntry2 = allRawEntries.next();
               if (rawEntry2.done) return;
@@ -2129,8 +2231,8 @@ var CoStreamProxyHandler = {
                 target._schema[ItemsSym]
               );
             }
-          }();
-        }
+          })();
+        },
       });
       return entry;
     } else if (key === "perSession") {
@@ -2149,7 +2251,12 @@ var CoStreamProxyHandler = {
     }
   },
   defineProperty(target, key, descriptor) {
-    if (descriptor.value && key === ItemsSym && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
+    if (
+      descriptor.value &&
+      key === ItemsSym &&
+      typeof descriptor.value === "object" &&
+      SchemaInit in descriptor.value
+    ) {
       target.constructor._schema ||= {};
       target.constructor._schema[ItemsSym] = descriptor.value[SchemaInit];
       return true;
@@ -2169,12 +2276,12 @@ var CoStreamProxyHandler = {
       return {
         configurable: true,
         enumerable: true,
-        writable: false
+        writable: false,
       };
     } else {
       return Reflect.getOwnPropertyDescriptor(target, key);
     }
-  }
+  },
 };
 var CoStreamPerSessionProxyHandler = (innerTarget, accessFrom) => ({
   get(_target, key, receiver) {
@@ -2193,7 +2300,7 @@ var CoStreamPerSessionProxyHandler = (innerTarget, accessFrom) => ({
       Object.defineProperty(entry, "all", {
         get: () => {
           const allRawEntries = innerTarget._raw.itemsIn(sessionID);
-          return function* () {
+          return (function* () {
             while (true) {
               const rawEntry2 = allRawEntries.next();
               if (rawEntry2.done) return;
@@ -2205,8 +2312,8 @@ var CoStreamPerSessionProxyHandler = (innerTarget, accessFrom) => ({
                 innerTarget._schema[ItemsSym]
               );
             }
-          }();
-        }
+          })();
+        },
       });
       return entry;
     } else {
@@ -2221,12 +2328,12 @@ var CoStreamPerSessionProxyHandler = (innerTarget, accessFrom) => ({
       return {
         configurable: true,
         enumerable: true,
-        writable: false
+        writable: false,
       };
     } else {
       return Reflect.getOwnPropertyDescriptor(target, key);
     }
-  }
+  },
 });
 var FileStream = class extends CoValueBase {
   constructor(options) {
@@ -2241,10 +2348,10 @@ var FileStream = class extends CoValueBase {
     Object.defineProperties(this, {
       id: {
         value: raw.id,
-        enumerable: false
+        enumerable: false,
       },
       _type: { value: "BinaryCoStream", enumerable: false },
-      _raw: { value: raw, enumerable: false }
+      _raw: { value: raw, enumerable: false },
     });
   }
   static create(options) {
@@ -2267,7 +2374,7 @@ var FileStream = class extends CoValueBase {
   }
   toBlob(options) {
     const chunks = this.getChunks({
-      allowUnfinished: options?.allowUnfinished
+      allowUnfinished: options?.allowUnfinished,
     });
     if (!chunks) {
       return void 0;
@@ -2292,7 +2399,7 @@ var FileStream = class extends CoValueBase {
       });
     }
     return stream?.toBlob({
-      allowUnfinished: options?.allowUnfinished
+      allowUnfinished: options?.allowUnfinished,
     });
   }
   /**
@@ -2314,7 +2421,7 @@ var FileStream = class extends CoValueBase {
     stream.start({
       mimeType: blob.type,
       totalSizeBytes: blob.size,
-      fileName: blob instanceof File ? blob.name : void 0
+      fileName: blob instanceof File ? blob.name : void 0,
     });
     const chunkSize = MAX_RECOMMENDED_TX_SIZE;
     let lastProgressUpdate = Date.now();
@@ -2332,7 +2439,7 @@ var FileStream = class extends CoValueBase {
       "Finished creating binary stream in",
       (end - start) / 1e3,
       "s - Throughput in MB/s",
-      1e3 * (blob.size / (end - start)) / (1024 * 1024)
+      (1e3 * (blob.size / (end - start))) / (1024 * 1024)
     );
     onProgress?.(1);
     return stream;
@@ -2345,7 +2452,7 @@ var FileStream = class extends CoValueBase {
     return {
       id: this.id,
       _type: this._type,
-      ...this.getChunks()
+      ...this.getChunks(),
     };
   }
   /** @internal */
@@ -2406,7 +2513,7 @@ var _CoList = class _CoList extends Array {
    */
   static Of(item) {
     var _a2, _b2;
-    return class CoListOf extends (_b2 = _CoList, _a2 = co.items, _b2) {
+    return class CoListOf extends ((_b2 = _CoList), (_a2 = co.items), _b2) {
       constructor() {
         super(...arguments);
         this[_a2] = item;
@@ -2425,7 +2532,9 @@ var _CoList = class _CoList extends Array {
   }
   /** @category Collaboration */
   get _owner() {
-    return this._raw.group instanceof RawAccount5 ? RegisteredSchemas["Account"].fromRaw(this._raw.group) : RegisteredSchemas["Group"].fromRaw(this._raw.group);
+    return this._raw.group instanceof RawAccount5
+      ? RegisteredSchemas["Account"].fromRaw(this._raw.group)
+      : RegisteredSchemas["Group"].fromRaw(this._raw.group);
   }
   /**
    * If a `CoList`'s items are a `co.ref(...)`, you can use `coList._refs[i]` to access
@@ -2458,9 +2567,8 @@ var _CoList = class _CoList extends Array {
   get _loadedAs() {
     const rawAccount = this._raw.core.node.account;
     if (rawAccount instanceof RawAccount5) {
-      return coValuesCache.get(
-        rawAccount,
-        () => RegisteredSchemas["Account"].fromRaw(rawAccount)
+      return coValuesCache.get(rawAccount, () =>
+        RegisteredSchemas["Account"].fromRaw(rawAccount)
       );
     }
     return new AnonymousJazzAgent(this._raw.core.node);
@@ -2472,15 +2580,15 @@ var _CoList = class _CoList extends Array {
     super();
     Object.defineProperty(this, "_instanceID", {
       value: `instance-${Math.random().toString(36).slice(2)}`,
-      enumerable: false
+      enumerable: false,
     });
     if (options && "fromRaw" in options) {
       Object.defineProperties(this, {
         id: {
           value: options.fromRaw.id,
-          enumerable: false
+          enumerable: false,
         },
-        _raw: { value: options.fromRaw, enumerable: false }
+        _raw: { value: options.fromRaw, enumerable: false },
       });
     }
     return new Proxy(this, CoListProxyHandler);
@@ -2515,9 +2623,9 @@ var _CoList = class _CoList extends Array {
     Object.defineProperties(instance, {
       id: {
         value: raw.id,
-        enumerable: false
+        enumerable: false,
       },
-      _raw: { value: raw, enumerable: false }
+      _raw: { value: raw, enumerable: false },
     });
     return instance;
   }
@@ -2547,7 +2655,11 @@ var _CoList = class _CoList extends Array {
   }
   splice(start, deleteCount, ...items) {
     const deleted = this.slice(start, start + deleteCount);
-    for (let idxToDelete = start + deleteCount - 1; idxToDelete >= start; idxToDelete--) {
+    for (
+      let idxToDelete = start + deleteCount - 1;
+      idxToDelete >= start;
+      idxToDelete--
+    ) {
       this._raw.delete(idxToDelete);
     }
     let appendAfter = Math.max(start - 1, 0);
@@ -2566,11 +2678,10 @@ var _CoList = class _CoList extends Array {
     } else if ("encoded" in itemDescriptor) {
       return this._raw.asArray().map((e) => itemDescriptor.encoded.encode(e));
     } else if (isRefEncoded(itemDescriptor)) {
-      return this.map(
-        (item, idx) => seenAbove?.includes(item?.id) ? { _circular: item.id } : item?.toJSON(idx + "", [
-          ...seenAbove || [],
-          this.id
-        ])
+      return this.map((item, idx) =>
+        seenAbove?.includes(item?.id)
+          ? { _circular: item.id }
+          : item?.toJSON(idx + "", [...(seenAbove || []), this.id])
       );
     } else {
       return [];
@@ -2687,9 +2798,16 @@ var _CoList = class _CoList extends Array {
 _CoList.prototype._type = "CoList";
 var CoList = _CoList;
 function toRawItems(items, itemDescriptor) {
-  const rawItems = itemDescriptor === "json" ? items : "encoded" in itemDescriptor ? items?.map((e) => itemDescriptor.encoded.encode(e)) : isRefEncoded(itemDescriptor) ? items?.map((v) => v.id) : (() => {
-    throw new Error("Invalid element descriptor");
-  })();
+  const rawItems =
+    itemDescriptor === "json"
+      ? items
+      : "encoded" in itemDescriptor
+      ? items?.map((e) => itemDescriptor.encoded.encode(e))
+      : isRefEncoded(itemDescriptor)
+      ? items?.map((v) => v.id)
+      : (() => {
+          throw new Error("Invalid element descriptor");
+        })();
   return rawItems;
 }
 var CoListProxyHandler = {
@@ -2700,13 +2818,16 @@ var CoListProxyHandler = {
       if (itemDescriptor === "json") {
         return rawValue;
       } else if ("encoded" in itemDescriptor) {
-        return rawValue === void 0 ? void 0 : itemDescriptor.encoded.decode(rawValue);
+        return rawValue === void 0
+          ? void 0
+          : itemDescriptor.encoded.decode(rawValue);
       } else if (isRefEncoded(itemDescriptor)) {
-        return rawValue === void 0 ? void 0 : new Ref(
-          rawValue,
-          target._loadedAs,
-          itemDescriptor
-        ).accessFrom(receiver, Number(key));
+        return rawValue === void 0
+          ? void 0
+          : new Ref(rawValue, target._loadedAs, itemDescriptor).accessFrom(
+              receiver,
+              Number(key)
+            );
       }
     } else if (key === "length") {
       return target._raw.entries().length;
@@ -2737,7 +2858,12 @@ var CoListProxyHandler = {
     }
   },
   defineProperty(target, key, descriptor) {
-    if (descriptor.value && key === ItemsSym && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
+    if (
+      descriptor.value &&
+      key === ItemsSym &&
+      typeof descriptor.value === "object" &&
+      SchemaInit in descriptor.value
+    ) {
       target.constructor._schema ||= {};
       target.constructor._schema[ItemsSym] = descriptor.value[SchemaInit];
       return true;
@@ -2751,12 +2877,12 @@ var CoListProxyHandler = {
     } else {
       return Reflect.has(target, key);
     }
-  }
+  },
 };
 
 // src/coValues/extensions/imageDef.ts
 var _a, _b;
-var ImageDefinition = class extends (_b = CoMap, _a = co.items, _b) {
+var ImageDefinition = class extends ((_b = CoMap), (_a = co.items), _b) {
   constructor() {
     super(...arguments);
     this.originalSize = co.json();
@@ -2770,7 +2896,10 @@ var ImageDefinition = class extends (_b = CoMap, _a = co.items, _b) {
       );
     }
     const resolutions = Object.keys(this).filter(
-      (key) => key.match(/^\d+x\d+$/) && (options?.maxWidth === void 0 || Number(key.split("x")[0]) <= options.maxWidth)
+      (key) =>
+        key.match(/^\d+x\d+$/) &&
+        (options?.maxWidth === void 0 ||
+          Number(key.split("x")[0]) <= options.maxWidth)
     );
     resolutions.sort((a, b) => {
       const aWidth = Number(a.split("x")[0]);
@@ -2782,16 +2911,20 @@ var ImageDefinition = class extends (_b = CoMap, _a = co.items, _b) {
       if (this[resolution] && this[resolution]?.getChunks()) {
         highestAvailableResolution = resolution;
       } else {
-        return highestAvailableResolution && {
-          res: highestAvailableResolution,
-          stream: this[highestAvailableResolution]
-        };
+        return (
+          highestAvailableResolution && {
+            res: highestAvailableResolution,
+            stream: this[highestAvailableResolution],
+          }
+        );
       }
     }
-    return highestAvailableResolution && {
-      res: highestAvailableResolution,
-      stream: this[highestAvailableResolution]
-    };
+    return (
+      highestAvailableResolution && {
+        res: highestAvailableResolution,
+        stream: this[highestAvailableResolution],
+      }
+    );
   }
 };
 
@@ -2832,9 +2965,7 @@ var SchemaUnion = class _SchemaUnion extends CoValueBase {
   static Of(discriminator) {
     return class SchemaUnionClass extends _SchemaUnion {
       static fromRaw(raw) {
-        const ResolvedClass = discriminator(
-          raw
-        );
+        const ResolvedClass = discriminator(raw);
         return ResolvedClass.fromRaw(raw);
       }
     };
@@ -2875,7 +3006,7 @@ export {
   FileStream,
   CoList,
   ImageDefinition,
-  SchemaUnion
+  SchemaUnion,
 };
 /* istanbul ignore file -- @preserve */
 //# sourceMappingURL=chunk-7LENDMTN.js.map
diff --git a/src/implementation/createContext.ts b/src/implementation/createContext.ts
index 8561cdb158cff24a1668530669048c4d8e57c9f5..87f685b4c26248fb30f5feef67bbc1a073767761 100644
--- a/src/implementation/createContext.ts
+++ b/src/implementation/createContext.ts
@@ -73,7 +73,7 @@ export const ephemeralCredentialsAuth = (): AuthMethod => {
 
 export async function randomSessionProvider(
   accountID: ID<Account>,
-  crypto: CryptoProvider,
+  crypto: CryptoProvider
 ) {
   return {
     sessionID: crypto.newRandomSessionID(accountID as unknown as RawAccountID),
@@ -86,7 +86,7 @@ type ContextParamsWithAuth<Acc extends Account> = {
   auth: AuthMethod;
   sessionProvider: (
     accountID: ID<Account>,
-    crypto: CryptoProvider,
+    crypto: CryptoProvider
   ) => Promise<{ sessionID: SessionID; sessionDone: () => void }>;
 } & BaseContextParams;
 
@@ -123,13 +123,14 @@ export async function createJazzContext({
   crypto,
 }: BaseContextParams): Promise<JazzContextWithAgent>;
 export async function createJazzContext<Acc extends Account>(
-  options: ContextParamsWithAuth<Acc> | BaseContextParams,
+  options: ContextParamsWithAuth<Acc> | BaseContextParams
 ): Promise<JazzContext<Acc>>;
 export async function createJazzContext<Acc extends Account>(
-  options: ContextParamsWithAuth<Acc> | BaseContextParams,
+  options: ContextParamsWithAuth<Acc> | BaseContextParams
 ): Promise<JazzContext<Acc>> {
   // eslint-disable-next-line no-constant-condition
   while (true) {
+    console.log("While true");
     if (!("auth" in options)) {
       return createAnonymousJazzContext({
         peersToLoadFrom: options.peersToLoadFrom,
@@ -143,6 +144,7 @@ export async function createJazzContext<Acc extends Account>(
       (RegisteredSchemas["Account"] as unknown as AccountClass<Acc>);
     let authResult: AuthResult;
     try {
+      console.log("Starting auth");
       authResult = await auth.start(crypto);
     } catch (e) {
       console.error("error", e);
@@ -151,12 +153,15 @@ export async function createJazzContext<Acc extends Account>(
 
     if (authResult.type === "existing") {
       try {
+        console.log("Starting session provider");
         const { sessionID, sessionDone } = await sessionProvider(
           authResult.credentials.accountID,
-          crypto,
+          crypto
         );
+        console.log("Session provider done");
 
         try {
+          console.log("Starting node with loaded account");
           const node = await LocalNode.withLoadedAccount({
             accountID: authResult.credentials
               .accountID as unknown as CoID<RawAccount>,
@@ -165,21 +170,25 @@ export async function createJazzContext<Acc extends Account>(
             peersToLoadFrom: peersToLoadFrom,
             crypto: crypto,
             migration: async (rawAccount, _node, creationProps) => {
+              console.log("Starting migration");
               const account = new AccountSchema({
                 fromRaw: rawAccount,
               }) as Acc;
 
               await account.applyMigration(creationProps);
+              console.log("Migration done");
             },
           });
-
+          console.log("Node with loaded account done");
           const account = AccountSchema.fromNode(node);
-
+          console.log("Account created");
           if (authResult.saveCredentials) {
+            console.log("Saving credentials");
             await authResult.saveCredentials({
               accountID: node.account.id as unknown as ID<Account>,
               secret: node.account.agentSecret,
             });
+            console.log("Credentials saved");
           }
 
           authResult.onSuccess();
@@ -202,7 +211,7 @@ export async function createJazzContext<Acc extends Account>(
         }
       } catch (e) {
         authResult.onError(
-          new Error("Error acquiring sessionID", { cause: e }),
+          new Error("Error acquiring sessionID", { cause: e })
         );
       }
     } else if (authResult.type === "new") {
@@ -260,7 +269,7 @@ export async function createAnonymousJazzContext({
   const node = new LocalNode(
     rawAgent,
     crypto.newRandomSessionID(rawAgent.id),
-    crypto,
+    crypto
   );
 
   for (const peer of peersToLoadFrom) {
