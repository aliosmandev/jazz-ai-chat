diff --git a/dist/web/localNode.js b/dist/web/localNode.js
index 62849f3bd1d5891bf8ecb7cb5693857d8722f932..4e0265164e2f49510e5710a8b14717768701949a 100644
--- a/dist/web/localNode.js
+++ b/dist/web/localNode.js
@@ -1,8 +1,12 @@
 import { ResultAsync, err, ok, okAsync } from "neverthrow";
 import { CoValuesStore } from "./CoValuesStore.js";
-import { CoValueCore, } from "./coValueCore.js";
-import { ControlledAgent, RawControlledAccount, accountHeaderForInitialAgentSecret, } from "./coValues/account.js";
-import { secretSeedFromInviteSecret, } from "./coValues/group.js";
+import { CoValueCore } from "./coValueCore.js";
+import {
+  ControlledAgent,
+  RawControlledAccount,
+  accountHeaderForInitialAgentSecret,
+} from "./coValues/account.js";
+import { secretSeedFromInviteSecret } from "./coValues/group.js";
 import { isAgentID } from "./ids.js";
 import { SyncManager } from "./sync.js";
 import { expectGroup } from "./typeUtils/expectGroup.js";
@@ -18,394 +22,495 @@ const { localNode } = useJazz();
 ```
 */
 export class LocalNode {
+  /** @category 3. Low-level */
+  constructor(account, currentSessionID, crypto) {
+    /** @internal */
+    this.coValuesStore = new CoValuesStore();
     /** @category 3. Low-level */
-    constructor(account, currentSessionID, crypto) {
-        /** @internal */
-        this.coValuesStore = new CoValuesStore();
-        /** @category 3. Low-level */
-        this.syncManager = new SyncManager(this);
-        this.crashed = undefined;
-        this.account = account;
-        this.currentSessionID = currentSessionID;
-        this.crypto = crypto;
+    this.syncManager = new SyncManager(this);
+    this.crashed = undefined;
+    this.account = account;
+    this.currentSessionID = currentSessionID;
+    this.crypto = crypto;
+  }
+  /** @category 2. Node Creation */
+  static async withNewlyCreatedAccount({
+    creationProps,
+    peersToLoadFrom,
+    migration,
+    crypto,
+    initialAgentSecret = crypto.newRandomAgentSecret(),
+  }) {
+    const throwawayAgent = crypto.newRandomAgentSecret();
+    const setupNode = new LocalNode(
+      new ControlledAgent(throwawayAgent, crypto),
+      crypto.newRandomSessionID(crypto.getAgentID(throwawayAgent)),
+      crypto
+    );
+    const account = setupNode.createAccount(initialAgentSecret);
+    const nodeWithAccount = account.core.node.testWithDifferentAccount(
+      account,
+      crypto.newRandomSessionID(account.id)
+    );
+    const accountOnNodeWithAccount = nodeWithAccount.account;
+    if (peersToLoadFrom) {
+      for (const peer of peersToLoadFrom) {
+        nodeWithAccount.syncManager.addPeer(peer);
+      }
     }
-    /** @category 2. Node Creation */
-    static async withNewlyCreatedAccount({ creationProps, peersToLoadFrom, migration, crypto, initialAgentSecret = crypto.newRandomAgentSecret(), }) {
-        const throwawayAgent = crypto.newRandomAgentSecret();
-        const setupNode = new LocalNode(new ControlledAgent(throwawayAgent, crypto), crypto.newRandomSessionID(crypto.getAgentID(throwawayAgent)), crypto);
-        const account = setupNode.createAccount(initialAgentSecret);
-        const nodeWithAccount = account.core.node.testWithDifferentAccount(account, crypto.newRandomSessionID(account.id));
-        const accountOnNodeWithAccount = nodeWithAccount.account;
-        if (peersToLoadFrom) {
-            for (const peer of peersToLoadFrom) {
-                nodeWithAccount.syncManager.addPeer(peer);
-            }
-        }
-        if (migration) {
-            await migration(accountOnNodeWithAccount, nodeWithAccount, creationProps);
-        }
-        else {
-            const profileGroup = accountOnNodeWithAccount.createGroup();
-            profileGroup.addMember("everyone", "reader");
-            const profile = profileGroup.createMap({
-                name: creationProps.name,
-            });
-            accountOnNodeWithAccount.set("profile", profile.id, "trusting");
-        }
-        const controlledAccount = new RawControlledAccount(accountOnNodeWithAccount.core, accountOnNodeWithAccount.agentSecret);
-        nodeWithAccount.account = controlledAccount;
-        nodeWithAccount.coValuesStore.setAsAvailable(controlledAccount.id, controlledAccount.core);
-        controlledAccount.core._cachedContent = undefined;
-        if (!controlledAccount.get("profile")) {
-            throw new Error("Must set account profile in initial migration");
-        }
-        // we shouldn't need this, but it fixes account data not syncing for new accounts
-        function syncAllCoValuesAfterCreateAccount() {
-            for (const coValueEntry of nodeWithAccount.coValuesStore.getValues()) {
-                if (coValueEntry.state.type === "available") {
-                    void nodeWithAccount.syncManager.syncCoValue(coValueEntry.state.coValue);
-                }
-            }
-        }
-        syncAllCoValuesAfterCreateAccount();
-        setTimeout(syncAllCoValuesAfterCreateAccount, 500);
-        return {
-            node: nodeWithAccount,
-            accountID: accountOnNodeWithAccount.id,
-            accountSecret: accountOnNodeWithAccount.agentSecret,
-            sessionID: nodeWithAccount.currentSessionID,
-        };
+    if (migration) {
+      await migration(accountOnNodeWithAccount, nodeWithAccount, creationProps);
+    } else {
+      const profileGroup = accountOnNodeWithAccount.createGroup();
+      profileGroup.addMember("everyone", "reader");
+      const profile = profileGroup.createMap({
+        name: creationProps.name,
+      });
+      accountOnNodeWithAccount.set("profile", profile.id, "trusting");
     }
-    /** @category 2. Node Creation */
-    static async withLoadedAccount({ accountID, accountSecret, sessionID, peersToLoadFrom, crypto, migration, }) {
-        try {
-            const loadingNode = new LocalNode(new ControlledAgent(accountSecret, crypto), crypto.newRandomSessionID(accountID), crypto);
-            for (const peer of peersToLoadFrom) {
-                loadingNode.syncManager.addPeer(peer);
-            }
-            const accountPromise = loadingNode.load(accountID);
-            const account = await accountPromise;
-            if (account === "unavailable") {
-                throw new Error("Account unavailable from all peers");
-            }
-            const controlledAccount = new RawControlledAccount(account.core, accountSecret);
-            // since this is all synchronous, we can just swap out nodes for the SyncManager
-            const node = loadingNode.testWithDifferentAccount(controlledAccount, sessionID || crypto.newRandomSessionID(accountID));
-            node.syncManager = loadingNode.syncManager;
-            node.syncManager.local = node;
-            controlledAccount.core.node = node;
-            node.coValuesStore.setAsAvailable(accountID, controlledAccount.core);
-            controlledAccount.core._cachedContent = undefined;
-            const profileID = account.get("profile");
-            if (!profileID) {
-                throw new Error("Account has no profile");
-            }
-            const profile = await node.load(profileID);
-            if (profile === "unavailable") {
-                throw new Error("Profile unavailable from all peers");
-            }
-            if (migration) {
-                await migration(controlledAccount, node);
-                node.account = new RawControlledAccount(controlledAccount.core, controlledAccount.agentSecret);
-            }
-            return node;
-        }
-        catch (e) {
-            console.error("Error withLoadedAccount", e);
-            throw e;
-        }
+    const controlledAccount = new RawControlledAccount(
+      accountOnNodeWithAccount.core,
+      accountOnNodeWithAccount.agentSecret
+    );
+    nodeWithAccount.account = controlledAccount;
+    nodeWithAccount.coValuesStore.setAsAvailable(
+      controlledAccount.id,
+      controlledAccount.core
+    );
+    controlledAccount.core._cachedContent = undefined;
+    if (!controlledAccount.get("profile")) {
+      throw new Error("Must set account profile in initial migration");
     }
-    /** @internal */
-    createCoValue(header) {
-        if (this.crashed) {
-            throw new Error("Trying to create CoValue after node has crashed", {
-                cause: this.crashed,
-            });
+    // we shouldn't need this, but it fixes account data not syncing for new accounts
+    function syncAllCoValuesAfterCreateAccount() {
+      for (const coValueEntry of nodeWithAccount.coValuesStore.getValues()) {
+        if (coValueEntry.state.type === "available") {
+          void nodeWithAccount.syncManager.syncCoValue(
+            coValueEntry.state.coValue
+          );
         }
-        const coValue = new CoValueCore(header, this);
-        this.coValuesStore.setAsAvailable(coValue.id, coValue);
-        void this.syncManager.syncCoValue(coValue);
-        return coValue;
+      }
     }
-    /** @internal */
-    async loadCoValueCore(id, skipLoadingFromPeer) {
-        if (this.crashed) {
-            throw new Error("Trying to load CoValue after node has crashed", {
-                cause: this.crashed,
-            });
-        }
-        const entry = this.coValuesStore.get(id);
-        if (entry.state.type === "unknown" || entry.state.type === "unavailable") {
-            const peers = this.syncManager.getServerAndStoragePeers(skipLoadingFromPeer);
-            await entry.loadFromPeers(peers).catch((e) => {
-                console.error("Error loading from peers", id, e);
-            });
-        }
-        return entry.getCoValue();
+    syncAllCoValuesAfterCreateAccount();
+    setTimeout(syncAllCoValuesAfterCreateAccount, 500);
+    return {
+      node: nodeWithAccount,
+      accountID: accountOnNodeWithAccount.id,
+      accountSecret: accountOnNodeWithAccount.agentSecret,
+      sessionID: nodeWithAccount.currentSessionID,
+    };
+  }
+  /** @category 2. Node Creation */
+  static async withLoadedAccount({
+    accountID,
+    accountSecret,
+    sessionID,
+    peersToLoadFrom,
+    crypto,
+    migration,
+  }) {
+    try {
+      console.log("[cojson] withLoadedAccount");
+      const loadingNode = new LocalNode(
+        new ControlledAgent(accountSecret, crypto),
+        crypto.newRandomSessionID(accountID),
+        crypto
+      );
+      console.log("[cojson] loadingNode");
+      for (const peer of peersToLoadFrom) {
+        loadingNode.syncManager.addPeer(peer);
+      }
+      console.log("[cojson] loadingNode.syncManager.addPeer");
+      const accountPromise = loadingNode.load(accountID);
+      console.log("[cojson] accountPromise");
+      const account = await accountPromise;
+      console.log("[cojson] account");
+      if (account === "unavailable") {
+        throw new Error("Account unavailable from all peers");
+      }
+      console.log("[cojson] account.core");
+      const controlledAccount = new RawControlledAccount(
+        account.core,
+        accountSecret
+      );
+      // since this is all synchronous, we can just swap out nodes for the SyncManager
+      console.log("[cojson] controlledAccount");
+      const node = loadingNode.testWithDifferentAccount(
+        controlledAccount,
+        sessionID || crypto.newRandomSessionID(accountID)
+      );
+      console.log("[cojson] node");
+      node.syncManager = loadingNode.syncManager;
+      console.log("[cojson] node.syncManager");
+      node.syncManager.local = node;
+      console.log("[cojson] node.syncManager.local");
+      controlledAccount.core.node = node;
+      console.log("[cojson] controlledAccount.core.node");
+      node.coValuesStore.setAsAvailable(accountID, controlledAccount.core);
+      console.log("[cojson] node.coValuesStore.setAsAvailable");
+      controlledAccount.core._cachedContent = undefined;
+      const profileID = account.get("profile");
+      if (!profileID) {
+        throw new Error("Account has no profile");
+      }
+      const profile = await node.load(profileID);
+      if (profile === "unavailable") {
+        throw new Error("Profile unavailable from all peers");
+      }
+      if (migration) {
+        await migration(controlledAccount, node);
+        node.account = new RawControlledAccount(
+          controlledAccount.core,
+          controlledAccount.agentSecret
+        );
+      }
+      return node;
+    } catch (e) {
+      console.error("Error withLoadedAccount", e);
+      throw e;
     }
-    /**
-     * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
-     * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
-     * for listening to subsequent updates to the CoValue.
-     *
-     * @category 3. Low-level
-     */
-    async load(id) {
-        const core = await this.loadCoValueCore(id);
-        if (core === "unavailable") {
-            return "unavailable";
-        }
-        return core.getCurrentContent();
+  }
+  /** @internal */
+  createCoValue(header) {
+    if (this.crashed) {
+      throw new Error("Trying to create CoValue after node has crashed", {
+        cause: this.crashed,
+      });
     }
-    getLoaded(id) {
-        const entry = this.coValuesStore.get(id);
-        if (entry.state.type === "available") {
-            return entry.state.coValue.getCurrentContent();
-        }
-        return undefined;
+    const coValue = new CoValueCore(header, this);
+    this.coValuesStore.setAsAvailable(coValue.id, coValue);
+    void this.syncManager.syncCoValue(coValue);
+    return coValue;
+  }
+  /** @internal */
+  async loadCoValueCore(id, skipLoadingFromPeer) {
+    if (this.crashed) {
+      throw new Error("Trying to load CoValue after node has crashed", {
+        cause: this.crashed,
+      });
     }
-    /** @category 3. Low-level */
-    subscribe(id, callback) {
-        let stopped = false;
-        let unsubscribe;
-        // console.log("Subscribing to " + id);
-        this.load(id)
-            .then((coValue) => {
-            if (stopped) {
-                return;
-            }
-            if (coValue === "unavailable") {
-                callback("unavailable");
-                return;
-            }
-            unsubscribe = coValue.subscribe(callback);
-        })
-            .catch((e) => {
-            console.error("Error subscribing to ", id, e);
-        });
-        return () => {
-            console.log("Unsubscribing from " + id);
-            stopped = true;
-            unsubscribe?.();
-        };
+    const entry = this.coValuesStore.get(id);
+    if (entry.state.type === "unknown" || entry.state.type === "unavailable") {
+      const peers =
+        this.syncManager.getServerAndStoragePeers(skipLoadingFromPeer);
+      await entry.loadFromPeers(peers).catch((e) => {
+        console.error("Error loading from peers", id, e);
+      });
     }
-    /** @deprecated Use Account.acceptInvite instead */
-    async acceptInvite(groupOrOwnedValueID, inviteSecret) {
-        const groupOrOwnedValue = await this.load(groupOrOwnedValueID);
-        if (groupOrOwnedValue === "unavailable") {
-            throw new Error("Trying to accept invite: Group/owned value unavailable from all peers");
-        }
-        if (groupOrOwnedValue.core.header.ruleset.type === "ownedByGroup") {
-            return this.acceptInvite(groupOrOwnedValue.core.header.ruleset.group, inviteSecret);
-        }
-        else if (groupOrOwnedValue.core.header.ruleset.type !== "group") {
-            throw new Error("Can only accept invites to groups");
-        }
-        const group = expectGroup(groupOrOwnedValue);
-        const inviteAgentSecret = this.crypto.agentSecretFromSecretSeed(secretSeedFromInviteSecret(inviteSecret));
-        const inviteAgentID = this.crypto.getAgentID(inviteAgentSecret);
-        const inviteRole = await new Promise((resolve, reject) => {
-            group.subscribe((groupUpdate) => {
-                const role = groupUpdate.get(inviteAgentID);
-                if (role) {
-                    resolve(role);
-                }
-            });
-            setTimeout(() => reject(new Error("Couldn't find invite before timeout")), 2000);
-        });
-        if (!inviteRole) {
-            throw new Error("No invite found");
-        }
-        const existingRole = group.get(this.account.id);
-        if (existingRole === "admin" ||
-            (existingRole === "writer" && inviteRole === "writerInvite") ||
-            (existingRole === "writer" && inviteRole === "reader") ||
-            (existingRole === "reader" && inviteRole === "readerInvite") ||
-            (existingRole && inviteRole === "writeOnlyInvite")) {
-            console.debug("Not accepting invite that would replace or downgrade role");
-            return;
+    return entry.getCoValue();
+  }
+  /**
+   * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
+   * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
+   * for listening to subsequent updates to the CoValue.
+   *
+   * @category 3. Low-level
+   */
+  async load(id) {
+    const core = await this.loadCoValueCore(id);
+    if (core === "unavailable") {
+      return "unavailable";
+    }
+    return core.getCurrentContent();
+  }
+  getLoaded(id) {
+    const entry = this.coValuesStore.get(id);
+    if (entry.state.type === "available") {
+      return entry.state.coValue.getCurrentContent();
+    }
+    return undefined;
+  }
+  /** @category 3. Low-level */
+  subscribe(id, callback) {
+    let stopped = false;
+    let unsubscribe;
+    // console.log("Subscribing to " + id);
+    this.load(id)
+      .then((coValue) => {
+        if (stopped) {
+          return;
         }
-        const groupAsInvite = expectGroup(group.core
-            .testWithDifferentAccount(new ControlledAgent(inviteAgentSecret, this.crypto), this.crypto.newRandomSessionID(inviteAgentID))
-            .getCurrentContent());
-        groupAsInvite.addMemberInternal(this.account, inviteRole === "adminInvite"
-            ? "admin"
-            : inviteRole === "writerInvite"
-                ? "writer"
-                : inviteRole === "writeOnlyInvite"
-                    ? "writeOnly"
-                    : "reader");
-        group.core._sessionLogs = groupAsInvite.core.sessionLogs;
-        group.core._cachedContent = undefined;
-        for (const groupListener of group.core.listeners) {
-            groupListener(group.core.getCurrentContent());
+        if (coValue === "unavailable") {
+          callback("unavailable");
+          return;
         }
+        unsubscribe = coValue.subscribe(callback);
+      })
+      .catch((e) => {
+        console.error("Error subscribing to ", id, e);
+      });
+    return () => {
+      console.log("Unsubscribing from " + id);
+      stopped = true;
+      unsubscribe?.();
+    };
+  }
+  /** @deprecated Use Account.acceptInvite instead */
+  async acceptInvite(groupOrOwnedValueID, inviteSecret) {
+    const groupOrOwnedValue = await this.load(groupOrOwnedValueID);
+    if (groupOrOwnedValue === "unavailable") {
+      throw new Error(
+        "Trying to accept invite: Group/owned value unavailable from all peers"
+      );
     }
-    /** @internal */
-    expectCoValueLoaded(id, expectation) {
-        const entry = this.coValuesStore.get(id);
-        if (entry.state.type !== "available") {
-            throw new Error(`${expectation ? expectation + ": " : ""}CoValue ${id} not yet loaded. Current state: ${entry.state.type}`);
-        }
-        return entry.state.coValue;
+    if (groupOrOwnedValue.core.header.ruleset.type === "ownedByGroup") {
+      return this.acceptInvite(
+        groupOrOwnedValue.core.header.ruleset.group,
+        inviteSecret
+      );
+    } else if (groupOrOwnedValue.core.header.ruleset.type !== "group") {
+      throw new Error("Can only accept invites to groups");
     }
-    /** @internal */
-    expectProfileLoaded(id, expectation) {
-        const account = this.expectCoValueLoaded(id, expectation);
-        const profileID = expectGroup(account.getCurrentContent()).get("profile");
-        if (!profileID) {
-            throw new Error(`${expectation ? expectation + ": " : ""}Account ${id} has no profile`);
+    const group = expectGroup(groupOrOwnedValue);
+    const inviteAgentSecret = this.crypto.agentSecretFromSecretSeed(
+      secretSeedFromInviteSecret(inviteSecret)
+    );
+    const inviteAgentID = this.crypto.getAgentID(inviteAgentSecret);
+    const inviteRole = await new Promise((resolve, reject) => {
+      group.subscribe((groupUpdate) => {
+        const role = groupUpdate.get(inviteAgentID);
+        if (role) {
+          resolve(role);
         }
-        return this.expectCoValueLoaded(profileID, expectation).getCurrentContent();
+      });
+      setTimeout(
+        () => reject(new Error("Couldn't find invite before timeout")),
+        2000
+      );
+    });
+    if (!inviteRole) {
+      throw new Error("No invite found");
     }
-    /** @internal */
-    createAccount(agentSecret = this.crypto.newRandomAgentSecret()) {
-        const accountAgentID = this.crypto.getAgentID(agentSecret);
-        const account = expectGroup(this.createCoValue(accountHeaderForInitialAgentSecret(agentSecret, this.crypto))
-            .testWithDifferentAccount(new ControlledAgent(agentSecret, this.crypto), this.crypto.newRandomSessionID(accountAgentID))
-            .getCurrentContent());
-        account.set(accountAgentID, "admin", "trusting");
-        const readKey = this.crypto.newRandomKeySecret();
-        const sealed = this.crypto.seal({
-            message: readKey.secret,
-            from: this.crypto.getAgentSealerSecret(agentSecret),
-            to: this.crypto.getAgentSealerID(accountAgentID),
-            nOnceMaterial: {
-                in: account.id,
-                tx: account.core.nextTransactionID(),
-            },
-        });
-        account.set(`${readKey.id}_for_${accountAgentID}`, sealed, "trusting");
-        account.set("readKey", readKey.id, "trusting");
-        const accountOnThisNode = this.expectCoValueLoaded(account.id);
-        accountOnThisNode._sessionLogs = new Map(account.core.sessionLogs);
-        accountOnThisNode._cachedContent = undefined;
-        return new RawControlledAccount(accountOnThisNode, agentSecret);
+    const existingRole = group.get(this.account.id);
+    if (
+      existingRole === "admin" ||
+      (existingRole === "writer" && inviteRole === "writerInvite") ||
+      (existingRole === "writer" && inviteRole === "reader") ||
+      (existingRole === "reader" && inviteRole === "readerInvite") ||
+      (existingRole && inviteRole === "writeOnlyInvite")
+    ) {
+      console.debug(
+        "Not accepting invite that would replace or downgrade role"
+      );
+      return;
     }
-    /** @internal */
-    resolveAccountAgent(id, expectation) {
-        if (isAgentID(id)) {
-            return ok(id);
-        }
-        let coValue;
-        try {
-            coValue = this.expectCoValueLoaded(id, expectation);
-        }
-        catch (e) {
-            return err({
-                type: "ErrorLoadingCoValueCore",
-                expectation,
-                id,
-                error: e,
-            });
-        }
-        if (coValue.header.type !== "comap" ||
-            coValue.header.ruleset.type !== "group" ||
-            !coValue.header.meta ||
-            !("type" in coValue.header.meta) ||
-            coValue.header.meta.type !== "account") {
-            return err({
-                type: "UnexpectedlyNotAccount",
-                expectation,
-                id,
-            });
-        }
-        return coValue.getCurrentContent().currentAgentID();
+    const groupAsInvite = expectGroup(
+      group.core
+        .testWithDifferentAccount(
+          new ControlledAgent(inviteAgentSecret, this.crypto),
+          this.crypto.newRandomSessionID(inviteAgentID)
+        )
+        .getCurrentContent()
+    );
+    groupAsInvite.addMemberInternal(
+      this.account,
+      inviteRole === "adminInvite"
+        ? "admin"
+        : inviteRole === "writerInvite"
+        ? "writer"
+        : inviteRole === "writeOnlyInvite"
+        ? "writeOnly"
+        : "reader"
+    );
+    group.core._sessionLogs = groupAsInvite.core.sessionLogs;
+    group.core._cachedContent = undefined;
+    for (const groupListener of group.core.listeners) {
+      groupListener(group.core.getCurrentContent());
     }
-    resolveAccountAgentAsync(id, expectation) {
-        if (isAgentID(id)) {
-            return okAsync(id);
-        }
-        return ResultAsync.fromPromise(this.loadCoValueCore(id), (e) => ({
-            type: "ErrorLoadingCoValueCore",
-            expectation,
-            id,
-            error: e,
-        })).andThen((coValue) => {
-            if (coValue === "unavailable") {
-                return err({
-                    type: "AccountUnavailableFromAllPeers",
-                    expectation,
-                    id,
-                });
-            }
-            if (coValue.header.type !== "comap" ||
-                coValue.header.ruleset.type !== "group" ||
-                !coValue.header.meta ||
-                !("type" in coValue.header.meta) ||
-                coValue.header.meta.type !== "account") {
-                return err({
-                    type: "UnexpectedlyNotAccount",
-                    expectation,
-                    id,
-                });
-            }
-            return coValue.getCurrentContent().currentAgentID();
-        });
+  }
+  /** @internal */
+  expectCoValueLoaded(id, expectation) {
+    const entry = this.coValuesStore.get(id);
+    if (entry.state.type !== "available") {
+      throw new Error(
+        `${
+          expectation ? expectation + ": " : ""
+        }CoValue ${id} not yet loaded. Current state: ${entry.state.type}`
+      );
     }
-    /**
-     * @deprecated use Account.createGroup() instead
-     */
-    createGroup(uniqueness = this.crypto.createdNowUnique()) {
-        const groupCoValue = this.createCoValue({
-            type: "comap",
-            ruleset: { type: "group", initialAdmin: this.account.id },
-            meta: null,
-            ...uniqueness,
-        });
-        const group = expectGroup(groupCoValue.getCurrentContent());
-        group.set(this.account.id, "admin", "trusting");
-        const readKey = this.crypto.newRandomKeySecret();
-        group.set(`${readKey.id}_for_${this.account.id}`, this.crypto.seal({
-            message: readKey.secret,
-            from: this.account.currentSealerSecret(),
-            to: this.account
-                .currentSealerID()
-                ._unsafeUnwrap({ withStackTrace: true }),
-            nOnceMaterial: {
-                in: groupCoValue.id,
-                tx: groupCoValue.nextTransactionID(),
-            },
-        }), "trusting");
-        group.set("readKey", readKey.id, "trusting");
-        return group;
+    return entry.state.coValue;
+  }
+  /** @internal */
+  expectProfileLoaded(id, expectation) {
+    const account = this.expectCoValueLoaded(id, expectation);
+    const profileID = expectGroup(account.getCurrentContent()).get("profile");
+    if (!profileID) {
+      throw new Error(
+        `${expectation ? expectation + ": " : ""}Account ${id} has no profile`
+      );
     }
-    /** @internal */
-    testWithDifferentAccount(account, currentSessionID) {
-        const newNode = new LocalNode(account, currentSessionID, this.crypto);
-        const coValuesToCopy = Array.from(this.coValuesStore.getEntries());
-        while (coValuesToCopy.length > 0) {
-            const [coValueID, entry] = coValuesToCopy[coValuesToCopy.length - 1];
-            if (entry.state.type !== "available") {
-                coValuesToCopy.pop();
-                continue;
-            }
-            else {
-                const allDepsCopied = entry.state.coValue
-                    .getDependedOnCoValues()
-                    .every((dep) => newNode.coValuesStore.get(dep).state.type === "available");
-                if (!allDepsCopied) {
-                    // move to end of queue
-                    coValuesToCopy.unshift(coValuesToCopy.pop());
-                    continue;
-                }
-                const newCoValue = new CoValueCore(entry.state.coValue.header, newNode, new Map(entry.state.coValue.sessionLogs));
-                newNode.coValuesStore.setAsAvailable(coValueID, newCoValue);
-                coValuesToCopy.pop();
-            }
-        }
-        if (account instanceof RawControlledAccount) {
-            // To make sure that when we edit the account, we're modifying the correct sessions
-            const accountInNode = new RawControlledAccount(newNode.expectCoValueLoaded(account.id), account.agentSecret);
-            if (accountInNode.core.node !== newNode) {
-                throw new Error("Account's node is not the new node");
-            }
-            newNode.account = accountInNode;
+    return this.expectCoValueLoaded(profileID, expectation).getCurrentContent();
+  }
+  /** @internal */
+  createAccount(agentSecret = this.crypto.newRandomAgentSecret()) {
+    const accountAgentID = this.crypto.getAgentID(agentSecret);
+    const account = expectGroup(
+      this.createCoValue(
+        accountHeaderForInitialAgentSecret(agentSecret, this.crypto)
+      )
+        .testWithDifferentAccount(
+          new ControlledAgent(agentSecret, this.crypto),
+          this.crypto.newRandomSessionID(accountAgentID)
+        )
+        .getCurrentContent()
+    );
+    account.set(accountAgentID, "admin", "trusting");
+    const readKey = this.crypto.newRandomKeySecret();
+    const sealed = this.crypto.seal({
+      message: readKey.secret,
+      from: this.crypto.getAgentSealerSecret(agentSecret),
+      to: this.crypto.getAgentSealerID(accountAgentID),
+      nOnceMaterial: {
+        in: account.id,
+        tx: account.core.nextTransactionID(),
+      },
+    });
+    account.set(`${readKey.id}_for_${accountAgentID}`, sealed, "trusting");
+    account.set("readKey", readKey.id, "trusting");
+    const accountOnThisNode = this.expectCoValueLoaded(account.id);
+    accountOnThisNode._sessionLogs = new Map(account.core.sessionLogs);
+    accountOnThisNode._cachedContent = undefined;
+    return new RawControlledAccount(accountOnThisNode, agentSecret);
+  }
+  /** @internal */
+  resolveAccountAgent(id, expectation) {
+    if (isAgentID(id)) {
+      return ok(id);
+    }
+    let coValue;
+    try {
+      coValue = this.expectCoValueLoaded(id, expectation);
+    } catch (e) {
+      return err({
+        type: "ErrorLoadingCoValueCore",
+        expectation,
+        id,
+        error: e,
+      });
+    }
+    if (
+      coValue.header.type !== "comap" ||
+      coValue.header.ruleset.type !== "group" ||
+      !coValue.header.meta ||
+      !("type" in coValue.header.meta) ||
+      coValue.header.meta.type !== "account"
+    ) {
+      return err({
+        type: "UnexpectedlyNotAccount",
+        expectation,
+        id,
+      });
+    }
+    return coValue.getCurrentContent().currentAgentID();
+  }
+  resolveAccountAgentAsync(id, expectation) {
+    if (isAgentID(id)) {
+      return okAsync(id);
+    }
+    return ResultAsync.fromPromise(this.loadCoValueCore(id), (e) => ({
+      type: "ErrorLoadingCoValueCore",
+      expectation,
+      id,
+      error: e,
+    })).andThen((coValue) => {
+      if (coValue === "unavailable") {
+        return err({
+          type: "AccountUnavailableFromAllPeers",
+          expectation,
+          id,
+        });
+      }
+      if (
+        coValue.header.type !== "comap" ||
+        coValue.header.ruleset.type !== "group" ||
+        !coValue.header.meta ||
+        !("type" in coValue.header.meta) ||
+        coValue.header.meta.type !== "account"
+      ) {
+        return err({
+          type: "UnexpectedlyNotAccount",
+          expectation,
+          id,
+        });
+      }
+      return coValue.getCurrentContent().currentAgentID();
+    });
+  }
+  /**
+   * @deprecated use Account.createGroup() instead
+   */
+  createGroup(uniqueness = this.crypto.createdNowUnique()) {
+    const groupCoValue = this.createCoValue({
+      type: "comap",
+      ruleset: { type: "group", initialAdmin: this.account.id },
+      meta: null,
+      ...uniqueness,
+    });
+    const group = expectGroup(groupCoValue.getCurrentContent());
+    group.set(this.account.id, "admin", "trusting");
+    const readKey = this.crypto.newRandomKeySecret();
+    group.set(
+      `${readKey.id}_for_${this.account.id}`,
+      this.crypto.seal({
+        message: readKey.secret,
+        from: this.account.currentSealerSecret(),
+        to: this.account
+          .currentSealerID()
+          ._unsafeUnwrap({ withStackTrace: true }),
+        nOnceMaterial: {
+          in: groupCoValue.id,
+          tx: groupCoValue.nextTransactionID(),
+        },
+      }),
+      "trusting"
+    );
+    group.set("readKey", readKey.id, "trusting");
+    return group;
+  }
+  /** @internal */
+  testWithDifferentAccount(account, currentSessionID) {
+    const newNode = new LocalNode(account, currentSessionID, this.crypto);
+    const coValuesToCopy = Array.from(this.coValuesStore.getEntries());
+    while (coValuesToCopy.length > 0) {
+      const [coValueID, entry] = coValuesToCopy[coValuesToCopy.length - 1];
+      if (entry.state.type !== "available") {
+        coValuesToCopy.pop();
+        continue;
+      } else {
+        const allDepsCopied = entry.state.coValue
+          .getDependedOnCoValues()
+          .every(
+            (dep) => newNode.coValuesStore.get(dep).state.type === "available"
+          );
+        if (!allDepsCopied) {
+          // move to end of queue
+          coValuesToCopy.unshift(coValuesToCopy.pop());
+          continue;
         }
-        return newNode;
+        const newCoValue = new CoValueCore(
+          entry.state.coValue.header,
+          newNode,
+          new Map(entry.state.coValue.sessionLogs)
+        );
+        newNode.coValuesStore.setAsAvailable(coValueID, newCoValue);
+        coValuesToCopy.pop();
+      }
     }
-    gracefulShutdown() {
-        this.syncManager.gracefulShutdown();
+    if (account instanceof RawControlledAccount) {
+      // To make sure that when we edit the account, we're modifying the correct sessions
+      const accountInNode = new RawControlledAccount(
+        newNode.expectCoValueLoaded(account.id),
+        account.agentSecret
+      );
+      if (accountInNode.core.node !== newNode) {
+        throw new Error("Account's node is not the new node");
+      }
+      newNode.account = accountInNode;
     }
+    return newNode;
+  }
+  gracefulShutdown() {
+    this.syncManager.gracefulShutdown();
+  }
 }
 //# sourceMappingURL=localNode.js.map
